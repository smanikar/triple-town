1. Finding relevant neighbours
Directions
NW  N NE
 W  X  E
SW  S SE

If north is true, then check NW and NE
If south is true, then check SW and SE
If east  is true, then check NE and SE
If west  is true, then check NW and SW

1. Add rule 1 - Completed
2. Read from user and collapse - Completed
3. CLI for read
4. Automate game-board population
5. Presentation
6. No bangs





7. infix . hack
8. eq? is pointer equal


3/4 stuff to do
X 1. cyrstal - find first match, using for/first, return board by anding return (function name of for/first is or/map)
2. abstract replace/count
X 3. test cases for decide-move
4. write declarative programs - ie. write functions that do something for me instead of writing individual steps to get that output.
(NO) 5. use list-build to build list
X 6. remove un-necessary [empty, false cases]. define board as non emtpy list
X 7. fix floating-castle for 4 instead of 3.
8. test gen-input by using build list or make-list
X 9. replace module+ test by module test+ <name>
X 0. end main-loop when board is full

Questions
1. Are chest, large-chest they part of extended or basic? They are not marked extended on TTP
2. Same with rock?

2/10

tcp-listen port-no num bool
tcp-accept listner
handle in out
    (regexp-match #rx"^


X expression

(( a b)) is a=b
(xyz ...) is xyz = font

(match (+ 1 2)
['(n) "match char n"]
[`(,n) "match anything ie n]

[else "nothing"])

2/12

When summing a large list, do you worry to make it tail recursive and make it use constant space? 
NO. because the list anyway is of the order n. So if your computation takes order n then its only going to be 2n.

look up - trapolining

Analysing points
---------------
5325-5925
